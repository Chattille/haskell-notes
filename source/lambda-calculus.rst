.. highlight:: text
   :linenothreshold: 10

======
λ 演算
======

背景
====

- 1874 年，德国数学家\ :tr:`格奥尔格·康托尔 (Georg Cantor)`\ 创立集合论后，在审视数集时对极限的概念提出质疑，引起数学界的争论；德国数学家\ :tr:`戴维·希尔伯特 (David Hilbert)`\ 支持康托尔的质疑，并和其他形式主义者一样，希望基于集合论创立一套更正式、更严谨的数学证明体系；
- 1910-1913 年，英国数学家\ :tr:`伯兰特·罗素 (Bertrand Russell)`\ 和其老师\ :tr:`阿尔弗雷德·怀特海 (Alfred Whitehead)`\ 合著发表\ :title-reference:`《数学原理》`\ ，在书中发明了一套形式证明系统，用于描述逻辑和数学命题；
- 1928 年，希尔伯特在一次会议上提出了三大问题，并相信答案是肯定的：

  1. 数学是否\ :tr:`完备 (complete)`\ ：在一个形式系统中，任意公式都能从该系统中得出（即任意公式都为该系统的定理）则称该系统具有完备性；
  2. 数学是否\ :tr:`自洽 (consistent)`\ ：系统不产生悖论则称该系统具有自洽性；
  3. 数学是否\ :tr:`可判定 (decidable)`\ ：对任意一条命题，存在一种算法，可以判定该命题是否可以从公理推导出来，则称该系统具有可判定性；

- 1931 年，美籍奥地利数学家\ :tr:`库尔特·哥德尔 (Kurt Gödel)`\ 发表论文，证明了任何蕴含了基础算术公理的基本数学系统都是不完备的，称为哥德尔不完备第一定理；接着又证明了数学里任何自洽的形式系统都无法证明其自洽性，称为哥德尔不完备第二定理；
- 1936 年，英国数学家\ :tr:`艾伦·图灵 (Alan Turing)`\ 为解决判定性问题，提出一种基于状态的抽象计算模型——\ :tr:`图灵机 (Turing machine)`\ ，用于模拟数学运算的过程，并提出停机问题，从而证明了数学系统不可判定；
- 同一时期，图灵提出的图灵机引起了他博士生导师——美国数学家\ :tr:`阿隆佐·邱奇 (Alonzo Church)`\ 的注意，并用 :tr:`λ 演算 (λ calculus)`\ 描述了计算的基本函数式概念，最终发现\ **图灵机与 λ 演算等价**\ ，任一图灵机中的程序都可以转化为一个等价的 λ 演算程序，反之亦然，以此提出邱奇-图灵猜想；

定义
====

.. productionlist::
   expression: name | function | application
   function: "λ" name "." expression
   application: expression expression

- :tr:`标识符 (name)`\ ：\ ``x``

  - 用于表示变量的任意名字；
  - 名字没有任何含义，仅区分不同变量，名字相同代表变量相同；
  - 分类：

    - 约束变量：在函数头中出现的变量（即参数），如\ ``λx.y``\ 中的\ ``x``\ ；
    - 自由变量：未在函数头中出现的变量，如\ ``λx.y``\ 中的\ ``y``\ ；

- :tr:`函数 (function)`\ ：\ ``λx.x+1``

  - 字母\ ``λ``\ 无实际意义，仅标识一个函数的开始；
  - ``λ``\ 之后\ ``.``\ 之前称为\ :tr:`函数头 (head)`\ ，放置变量（即参数）；
  - ``.``\ 表示将\ ``name``\ 绑定/约束于该函数体\ ``expression``\ ；
  - ``.``\ 之后称为\ :tr:`函数体 (body)`\ ，可放置表达式；

    - 函数体不作任何计算，只作\ :tr:`解析 (resolving)`\ ，解析完成则函数应用完成；
    - 函数体尽可能向右扩展，即\ ``λx.M N``\ 等价于\ ``λx.(M N)``\ ，而非\ ``(λx.M) N``\ ；

- :tr:`应用 (application)`\ ：\ ``(λx.x+1) a``

  - 传入后一个表达式，调用前一个表达式；
  - 默认为左结合，即从左向右执行，则有\ ``M N P``\ 等价于\ ``(M N) P``\ ；
  - 应用函数后根据\ :ref:`运算法则 <lambda-calculus:运算法则>`\ 进行演算；

- :tr:`表达式 (expression)`\ ：\ ``(λx.(λy.x y)) (λi.i)``

  - 一行符号称为表达式；
  - 允许使用括号组织表达式，改变优先级；

  .. attention::

     在 λ 演算的世界中，只存在上述的标识符、函数和应用三种语法，此处的\ ``+``\ 仅为方便表示抽象的“相加”函数操作，不表示实际表达式内容。λ 演算中加法的实际定义见\ :ref:`后文 <lambda-calculus:加法>`\ 。

柯里化
======

- :tr:`柯里化 (currying)`\ ：

  - 以美国逻辑学家\ :tr:`哈斯克尔·柯里 (Haskell Curry)`\ 的名字命名的一种技术，最先由乌克兰裔俄罗斯学者 Moses Schönfinkel 发现；
  - 根据\ :ref:`上述定义 <abnf>`\ ，一个函数只接受一个参数，通过柯里化技术可以实现多个参数的接受；

- 实现：一个函数的输入和输出都可以是函数，因此可以先接受一个参数，再返回接受余下参数的新函数；

  .. note::

     假设要实现一个函数，该函数接受两个参数并返回两参数之和，则\ ``λx y.x+y``\ 可以写作\ ``λx.(λy.x+y)``\ ，当传入第一个参数\ ``a``\ 时，该函数\ :ref:`返回另一个函数 <lambda-calculus:beta 归约>`\ ``λy.a+y``\ ，并继续接受第二个参数。

- 因为函数体是向右扩展的，因此\ ``λx.λy.M``\ 等价于\ ``λx.(λy.(M))``\ ，这种柯里化的函数可简记为多参数的形式\ ``λxy.M``\ （假设所有变量都为单字母）；
- 柯里化是\ :tr:`闭包 (closure)`\ 的鼻祖；

运算法则
========

- λ 演算在应用函数时只有三条运算法则：\ :ref:`Alpha 转换 <lambda-calculus:alpha 转换>`\ 、\ :ref:`Beta 归约 <lambda-calculus:beta 归约>`\ 和\ :ref:`Eta 转换 <lambda-calculus:eta 转换>`\ ；

Alpha 转换
----------

.. code-block::

   alpha[x/y]

- :tr:`Alpha 转换 (α conversion)`\ ：即约束变量重命名；

  - 在 λ 演算中，变量的名字并不重要，因此在为函数体中的约束变量重命名之后，函数在重命名前与重命名后是等价的；
  - Alpha 转换可记为\ ``alpha[x/y]``，表示\ ``x``\ 变为\ ``y``\ ；

- :tr:`命名冲突 (name clash)`\ ：当对约束变量进行 Alpha 转换时，可能会与自由变量发生命名冲突，此时函数重命名前后不等价；

  .. code-block::

     alpha[a/b] (λa.a+b) -> (λb.b+b)

- 某些编译器在编译时会包括 Alpha 转换阶段，对程序中的所有变量进行重命名，使变量唯一；

Beta 归约
---------

.. code-block::

   [x:=y]

- :tr:`Beta 归约 (β reduction)`\ ：

  - 当应用函数时，用后一个表达式替换函数体中的相关约束变量；
  - Beta 归约可记为\ ``[x:=y]``\ ，表示用\ ``y``\ 替换\ ``x``\ ；
  - 可理解为用实参替换形参的过程；
  - 根据 Beta 归约，可得结果：

  .. code-block::

     (λx.M) y ≡ M[x:=y]

- Alpha 转换：在进行 Beta 归约之前，首先要保证约束变量和自由变量不发生冲突，因此有时有必要首先进行 Alpha 转换；

  .. note::

     有函数\ ``λz.(λx.x+z)``\ ，若应用于表达式\ ``x+2``\ ，则根据 Beta 归约，应用的结果为\ ``λx.x+x+2``\ ，此时第一个\ ``x``\ 原为约束变量，第二个\ ``x``\ 原为自由变量，但 Beta 归约后自由变量与函数进行了绑定，发生命名冲突。

Eta 转换
--------

- :tr:`Eta 转换 (η conversion)`\ ：在等价表达式之间转换；
- 等价：若有两个函数，对于相同输入产生了相同输出，则称这两个函数等价；
- 分类：

  - :tr:`Eta 归约 (η reduction)`\ ：当两个表达式等价时，将更复杂的表达式归约为更简洁的表达式；

    .. note::

       有函数\ ``λx.M x``\ ，则表达式\ ``(λx.M x) a``\ 有结果\ ``M a``\ ，因此可得\ ``λx.M x ≡ M``\ ，进行 Eta 归约后，\ ``λx.M x``\ 归约为\ ``M``\ 。

  - :tr:`Eta 抽象/扩展 (η abstraction/expansion)`\ ：当两个表达式等价时，将更简洁的表达式扩展为更复杂的表达式；

- Eta 转换有利于\ :tr:`无值 (pointfree)`\ 编程，某些编译器在编译时会进行 Eta 转换；

编码
====

- 邱奇-图灵猜想：所有计算或算法都可以由一台图灵机来执行，以任何常规编程语言编写的计算机程序都可以翻译成一台图灵机；
- 由于 λ 演算是图灵机的等价形式，因此该猜想同样适用于 λ 演算；
- 在 λ 演算的世界中只存在函数，不存在非函数的数据类型（如数字、布尔值等），但λ演算可以通过函数对其他数据类型进行\ :tr:`编码 (encode)`\ ；

算术运算
--------

自然数
~~~~~~

- 思路：定义自然数首先从\ ``0``\ 开始，然后使用\ :tr:`后继函数 (successor)`\ 得到其余所有自然数；
- ``0``\ ：

  .. code-block::

     0 = λx.(λy.y)

- 后继函数：

  .. code-block::
     :name: successor

     SUCC = λa.(λb.(λc.b (a b c)))

  - 因为\ ``1``\ 定义为\ ``0``\ 的后继，则\ ``1``\ 可以表示为：

    .. code-block::

          SUCC 0
       -> (λa.(λb.(λc.b (a b c)))) 0
       -> λb.(λc.b (0 b c))
       -> λb.(λc.b ((λx.(λy.y)) b c))
       -> λb.(λc.b c)
       -> alpha[b c/x y] λb.(λc.b c)
       -> λx.(λy.x y)

  - 因为\ ``2``\ 定义为\ ``1``\ 的后继，则\ ``2``\ 可以表示为：

    .. code-block::

          SUCC 1
       -> λa.(λb.(λc.b (a b c))) 1
       -> λb.(λc.b (1 b c))
       -> λb.(λc.b ((λx.(λy.x y)) b c))
       -> λb.(λc.b (b c))
       -> alpha[b c/x y] λb.(λc.b (b c))
       -> λx.(λy.x (x y))

- 自然数：其余自然数只是在\ ``0``\ 的基础上不断叠加应用\ ``x``\ ；

  .. code-block::

     0 = λx.(λy.y)
     1 = λx.(λy.x y)
     2 = λx.(λy.x (x y))
     3 = λx.(λy.x (x (x y)))
     4 = λx.(λy.x (x (x (x y))))
     ...

  .. note::

     虽然用这种方法表示数字很奇怪，但是从数学角度上看两种表示方式并无差别，都是人为定义的符号。

加法
~~~~

.. code-block::

   x SUCC y

- 思路：当一个自然数接受第一个参数时，该参数会重复该自然数的次数，且每次都对第二个参数进行应用，因此将\ :ref:`后继函数 <successor>`\ 传入自然数中，后继函数就会对第二个参数重复应用相等次数；

.. code-block::

      3 + 5
   -> 3 SUCC 5
   -> λx.(λy.x (x (x y))) SUCC 5
   -> SUCC (SUCC (SUCC 5))
   -> λx.(λy.x (x (x (x (x (x (x (x y))))))))
   -> 8

乘法
~~~~

.. code-block::

   MULTIPLY = λa.(λb.(λc.a (b c)))

- 思路：将\ ``c``\ 传入自然数\ ``b``\ 后，得到\ ``b``\ 个\ ``c``\ ，再将结果传入自然数\ ``a``\ ，得到\ ``a``\ 个“\ ``b``\ 个\ ``c``\ ”；

.. code-block::

      2 * 3
   -> MULTIPLY 2 3
   -> λc.2 (3 c)
   -> λc.(λy.(3 c) ((3 c) y))
   使 ((3 c) y) = (c (c (c y))) = a
   -> λc.(λy.3 c a)
   -> λc.(λy.c (c (c a)))
   -> λc.(λy.c (c (c (c (c (c y))))))
   -> 6

减法
~~~~

- :tr:`前趋函数 (predecessor)`\ ：减法作为加法的对立，可以通过构造一个前趋函数来实现；
- 思路：

  - 一个自然数从\ ``0``\ 构造而来，其自身等价于\ ``x SUCC 0``\ ，若能够将\ ``x-1``\ 次（即倒数第一次，或前一次）计算的结果保留，则可以实现这个前趋函数；
  - 一个自然数无法达到目的，但可以通过构造用两个自然数构成的数对来达成；
  - 有数对\ ``(a,b)``\ ，可以用数对的第一个成员保存调用后继函数后的结果，用第二个成员保存调用后继函数前的原值，这种方式可以获取前一次的计算结果；
  - 设应用后继函数的次数为\ ``n``\ ，则为了获取\ ``n-1``\ 的值，可以从\ ``(0,-1)``\ 或\ ``(0,0)``\ 开始计算，这样\ ``n``\ 次后可得数对\ ``(n,n-1)``\ ，此时获取第二个成员则达到目的；
  - 因为数对\ ``(a,b)``\ 的第二个成员始终会被舍弃，因此从\ ``(0,0)``\ 开始与从\ ``(0,-1)``\ 开始并无差别；

- 实现：

  - 因为要获取第二个成员（通过\ ``λx.(λy.y)``\ 获取），所以可定义数对\ ``(a,b)``\ 为下述形式，则最小数对为\ ``λp.p 0 0``\ ：

    .. code-block::

       PAIR = λp.p a b

  - 将数对的第一个成员取出，获取应用后继函数前的原值：

    .. code-block::

       PAIR 1 -> (λp.p a b) 1 -> λx.(λy.x) a b -> a

  - 通过后继函数获得\ ``a+1``\ ：\ ``SUCC (PAIR 1)``\ ；
  - 因此，下述函数可以通过\ ``(a,b)``\ 得到新数对\ ``(a+1,a)``\ ，该函数接受一个数对作为参数；

    .. code-block::

       NEXTPAIR = λx.(λy.y (SUCC (x 1)) (x 1))
                = λx.(λy.y (SUCC (x (λx.(λy.x)))) (x (λx.(λy.x))))

    .. code-block::

          NEXTPAIR (2,3)
       -> λy.y (SUCC ((2,3) 1)) ((2,3) 1)
       -> λy.y (SUCC ((λp.p 2 3) 1)) ((λp.p 2 3) 1)
       -> λy.y (SUCC 2) 2
       -> λy.y 3 2
       -> (3,2)

  - 将该函数对数对\ ``(a,b)``\ 应用\ ``n``\ 次，可以得到新数对\ ``(a+n,a+n-1)``\ ，则当\ ``a``\ 等于\ ``0``\ 时，可得\ ``(n,n-1)``\ ；

    .. code-block::

       2 NEXTPAIR (0,0) -> NEXTPAIR (1,0) -> (2,1)

  - 构造函数，取出数对中的第二个成员，即可得到前趋函数：

    .. code-block::

       PRED = λn.(n NEXTPAIR λp.p 0 0) λi.(λj.j)

- 结果：前趋函数接受一个自然数作为参数；

  .. code-block::

     NEXTPAIR = λx.(λy.y (SUCC (x (λx.(λy.x)))) (x (λx.(λy.x))))
     PRED     = λn.(n NEXTPAIR λp.p 0 0) λx.(λy.y)

- 减法：与\ :ref:`加法 <lambda-calculus:加法>`\ 同理：

  .. code-block::

     x PRED y

逻辑运算
--------

布尔值
~~~~~~

.. code-block::

   TRUE  = λx.(λy.x)
   FALSE = λx.(λy.y)

- 真值：定义为函数，该函数传入两个参数，始终返回前一个参数；
- 假值：定义为函数，该函数传入两个参数，始终返回后一个参数；

  .. note::

     假值\ ``FALSE``\ 的定义与\ ``0``\ 相同，约束变量均被丢弃，返回后一个值。

逻辑否
~~~~~~

.. code-block::

   NOT = λb.b FALSE TRUE

- 逻辑否可定义为以上形式，接受一个布尔值作为参数，返回一个布尔值；

.. code-block::

      NOT TRUE
   -> (λb.b FALSE TRUE) TRUE
   -> TRUE FALSE TRUE
   -> (λx.(λy.x)) FALSE TRUE
   -> FALSE

逻辑与
~~~~~~

.. code-block::

   AND = λb1.(λb2.b1 b2 FALSE)

- 逻辑与可定义为以上形式，接受两个布尔值作为参数，返回一个布尔值；

.. code-block::

      AND TRUE TRUE
   -> (λb1.(b2.b1 b2 FALSE)) TRUE TRUE
   -> TRUE TRUE FALSE
   -> (λx.(λy.x)) TRUE FALSE
   -> TRUE

.. code-block::

      AND TRUE FALSE
   -> (λb1.(b2.b1 b2 FALSE)) TRUE FALSE
   -> TRUE FALSE FALSE
   -> FALSE

逻辑或
~~~~~~

.. code-block::

   OR = λb1.(λb2.b1 TRUE b2)

- 逻辑或可定义为以上形式，接受两个布尔值作为参数，返回一个布尔值；

.. code-block::

      OR TRUE FALSE
   -> λb1.(λb2.b1 TRUE b2) TRUE FALSE
   -> TRUE TRUE FALSE
   -> TRUE

.. code-block::

      OR FALSE TRUE
   -> λb1.(λb2.b1 TRUE b2) FALSE TRUE
   -> FALSE TRUE TRUE
   -> TRUE

条件
~~~~

.. code-block::

   IF = λx.(x FALSE NOT FALSE)

- ``IF``\ 函数接受一个\ :ref:`自然数 <lambda-calculus:自然数>`\ 作为参数，若为\ ``0``\ ，则返回\ ``TRUE``\ ，否则返回\ ``FALSE``\ ；

.. code-block::

      IF 0
   -> (λx.(x FALSE NOT FALSE)) 0
   -> (λx.(λy.y)) FALSE NOT FALSE
   -> NOT FALSE
   -> TRUE

.. code-block::

      IF 2
   -> λx.(x FALSE NOT FALSE) 2
   -> 2 FALSE NOT FALSE
   -> (λx.(λy.x (x y))) FALSE NOT FALSE
   -> FALSE (FALSE NOT) FALSE
   -> FALSE

比较
~~~~

- 大于等于：

  .. code-block::

     GE = λx.(λy.IF (x PRED y))

  - 思路：对\ ``y``\ 调用\ ``x``\ 次\ ``PRED``\ ，若为零则说明两者相等或\ ``x``\ 大于\ ``y``\ ；

  .. code-block::

        GE 3 4
     -> (λx.(λy.IF (x PRED y))) 3 4
     -> IF (3 PRED 4)
     -> IF 1
     -> FALSE

  .. code-block::

        GE 5 2
     -> (λx.(λy.IF (x PRED y))) 5 2
     -> IF (5 PRED 2)
     -> IF 0
     -> TRUE

- 等于：

  .. code-block::

     EQUAL = λx.(λy.AND (GE x y) (GE y x))

  - 思路：当\ ``GE x y``\ 为真且\ ``GE y x``\ 为真时，可以确定相等关系；

  .. code-block::

        EQUAL 3 3
     -> AND (GE 3 3) (GE 3 3)
     -> AND TRUE TRUE
     -> TRUE

  .. code-block::

        EQUAL 4 3
     -> AND (GE 4 3) (GE 3 4)
     -> AND TRUE FALSE
     -> FALSE

递归（Y 组合子）
----------------

.. code-block::

   Y = λf.(λx.f (x x)) (λx.f (x x))

- :tr:`不动点 (fixed point)`\ ：一个由函数\ ``f``\ 映射到其自身的值，即\ ``f x -> x``\ 中，\ ``x``\ 为函数\ ``f``\ 的不动点；
- :tr:`Y 组合子 (Y combinator)`\ ：由\ :tr:`哈斯克尔·柯里 (Haskell Curry)`\ 定义，用于计算高阶函数的不动点，使得 λ 演算可以在不支持递归的场合中实现递归；
- 思路：

  - 递归即自己定义自己，一个最简单的递归：

    .. code-block::

       LOOP = LOOP

  - 在构造函数时，函数至少接受一个参数，因此该参数可以设定为该函数本身，即函数\ ``g``\ 有\ ``g g``\ ，称为\ :tr:`自我应用 (self-application)`\ ；
  - 通过模仿最外层\ ``g g``\ 的结构，可以构造出函数\ ``g``\ 的函数体，该函数无论如何，得到的结构始终是\ ``g g``\ ；

    .. code-block::

       LOOP = (λx.x x) (λx.x x)

  - 若要得到函数\ ``f``\ ，使其满足\ ``f a -> a``\ ，则修改函数\ ``g``\ 的内部结构，可得：

    .. code-block::

       f (x x) -> (x x)

  - 因此Y组合子为：

    .. code-block::

       Y = λf.(λx.f (x x)) (λx.f (x x))

.. code-block::

      Y a
   -> (λf.(λx.f (x x)) (λx.f (x x))) a
   -> (λx.a (x x)) (λx.a (x x))
   -> a ((λx.a (x x)) (λx.a (x x)))
   -> a (Y a)
   -> a (a (Y a))
   ...
